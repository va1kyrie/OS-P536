# Assignment 6

I will be the first to admit this assignment got the best of me in a lot of ways. I spent a fair amount of time just trying to figure out what was going on with the code and how, exactly, all the structs and arrays interacted with each other.

My implementation of the filesystem functions is largely based on what was there already and the test file; there are additional things I would like to implement in theory concerning the file system, but I'm not sure where to start in terms of actually implementing them. For instance, my implementation of ```fs_read``` and ```fs_write``` both laregly assume friendly inputs - while I did add a rudimentary 'size' option to my filesystem struct so I could prevent _reading_ over the end of a file, the size is entirely decided by the writing function and doesn't do any "border control" (for lack of a better term) that way.

All the functions are implemented largely based on the behavior of ```xsh_test``` instead of any formal filesystem paradigm - as I said above, I got a bit lost in this assignment.

- ```fs_create``` first checks that the filename in question hasn't already been taken before assigning inodes, directory entries, and other struct details to new entries associated with the filename provided. It finishes by running ```fs_open``` to open the new file and returns the open file table entry for the new file.
- ```fs_open``` checks whether the filename exists in the open file table. If it does and the file is already open, it returns an error because the file cannot be opened twice at the same time. If it's closed, the function opens the file and returns the index in the open file table. If the file doesn't exist within the open file table or the root directory itself, it returns an error. If the file exists but doesn't have an open file table entry, ```fs_open``` creates one and returns the index of that entry.
- ```fs_close``` performs the same checks as the open function with one distinction: if the file has an entry in the open file table and it is already closed, the function simply returns a success because there is nothing to change and, technically, nothing has gone wrong. The major thing ```fs_close``` does is change the state of the file entry in the open file table from ```FSTATE_OPEN``` to ```FSTATE_CLOSED```.
- ```fs_seek``` simply changes the value of ```fileptr``` associated with the file in question. It also performs similar checks to the three functions above, and it will only change the value of ```fileptr``` on an open file. The seek function is also one of two functions to perform tests on the size of the file - you can't point the file pointer beyond the end of the file (as determined by the ```size``` field I - very basically - implemented).
- ```fs_read``` and ```fs_write``` are essentially the same functions mirroring each other, naturally. Using the block get and put methods in ```bs.c```, they each either read or write data between buffers and memory, where the file resides. The read function is the second function to use ```size``` as a basic check against going past the end of the file. ```fs_write``` sets size just before returning based on the number of bytes written, but doesn't itself perform any checks.

The main lesson I learned during this assignment are that file systems are complicated. I knew this, certainly, from class and other courses I've taken, but there's something different about trying to implement even the most basic one myself that really brings the message home. On a technical level, I learned (or relearned, rather) that offsets can be subtle and tricky to deal with, and a combination of confusing code and a confused coder can create an awful lot of offset errors.

I also had hammered home the fact that file system security, even at the most basic level, can add a lot of headache to your code. Even just adding the concept of 'size' created some interesting issues as I first tried to add those checks. I'm also not sure if my size checks are actually that effective - not just because 'write' doesn't have any such checks but still sets those values, but because one of my offset errors was fixed in a way I don't completely understand. (It had to do with how many times a while loop in the read function looped. For some reason, one more loop was needed, but I'm not sure why. I have a sinking feeling it may negate my check against the size of the file, though.)

All things considered, I definitely learned a lot during this assignment, including that I really don't know a lot about file systems and how they're implemented.
